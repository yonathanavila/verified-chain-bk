use ethereum_types::Address;
use halo2curves::bn256::Fr;
use halo2curves::bn256::G1Affine;
use log::{debug, trace};
use serde::{Deserialize, Serialize};
use snark_verifier::loader::evm::encode_calldata;
use snark_verifier::loader::evm::ExecutorBuilder;
use std::error::Error;
use std::fs::File;
use std::io::{Read, Write};
use std::path::PathBuf;
use thiserror::Error;

use super::Snark;

/// Aggregate proof generation for EVM
pub mod aggregation;
/// Simple (single) proof generation for EVM
pub mod single;

#[derive(Error, Debug)]
/// Errors related to evm verification
pub enum EvmVerificationError {
    /// If the Solidity verifier worked but returned false
    #[error("Solidity verifier found the proof invalid")]
    InvalidProof,
    /// If the Solidity verifier threw and error (e.g. OutOfGas)
    #[error("Execution of Solidity code failed")]
    SolidityExecution,
    /// EVM execution errors
    #[error("EVM execution of raw code failed")]
    RawExecution,
    /// EVM verify errors
    #[error("evm verification reverted")]
    Reverted,
    /// EVM verify errors
    #[error("evm deployment failed")]
    Deploy,
}

/// Defines the proof generated by a model / circuit suitably for serialization/deserialization.  
#[derive(Debug, Deserialize, Serialize)]
pub struct DeploymentCode {
    code: Vec<u8>,
}
impl DeploymentCode {
    /// Return len byte code
    pub fn len(&self) -> usize {
        self.code.len()
    }

    /// If no byte code
    pub fn is_empty(&self) -> bool {
        self.code.len() == 0
    }
    /// Return (inner) byte code
    pub fn code(&self) -> &Vec<u8> {
        &self.code
    }
    /// Saves the DeploymentCode to a specified `path`.
    pub fn save(&self, path: &PathBuf) -> Result<(), Box<dyn Error>> {
        let serialized = serde_json::to_string(&self).map_err(Box::<dyn Error>::from)?;

        let mut file = std::fs::File::create(path).map_err(Box::<dyn Error>::from)?;
        file.write_all(serialized.as_bytes())
            .map_err(Box::<dyn Error>::from)
    }

    /// Load a json serialized proof from the provided path.
    pub fn load(path: &PathBuf) -> Result<Self, Box<dyn Error>> {
        let mut file = File::open(path).map_err(Box::<dyn Error>::from)?;
        let mut data = String::new();
        file.read_to_string(&mut data)
            .map_err(Box::<dyn Error>::from)?;
        serde_json::from_str(&data).map_err(Box::<dyn Error>::from)
    }
}

/// Verify by executing bytecode with instance variables and proof as input
pub fn evm_verify(
    deployment_code: DeploymentCode,
    snark: Snark<Fr, G1Affine>,
) -> Result<bool, Box<dyn Error>> {
    debug!("evm deployment code length: {:?}", deployment_code.len());

    let calldata = encode_calldata(&snark.instances, &snark.proof);
    let mut evm = ExecutorBuilder::default()
        .with_gas_limit(u64::MAX.into())
        .build();

    let caller = Address::from_low_u64_be(0xfe);
    let deploy_result = evm.deploy(caller, deployment_code.code.into(), 0.into());
    debug!("evm deploy outcome: {:?}", deploy_result.exit_reason);
    trace!("full deploy result: {:?}", deploy_result);
    debug!("gas used for deployment: {}", deploy_result.gas_used);

    if let Some(verifier) = deploy_result.address {
        // Lot of stuff here as well.
        let result = evm.call_raw(caller, verifier, calldata.into(), 0.into());

        debug!("evm execution result: {:?}", result.exit_reason);
        trace!("full execution result: {:?}", result);
        debug!("gas used for execution: {}", result.gas_used);

        if result.reverted {
            return Err(Box::new(EvmVerificationError::Reverted));
        }

        Ok(!result.reverted)
    } else {
        Err(Box::new(EvmVerificationError::Deploy))
    }
}
